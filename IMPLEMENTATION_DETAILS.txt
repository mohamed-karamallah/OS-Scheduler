====================================
OS CPU SCHEDULER PROJECT - IMPLEMENTATION DETAILS
====================================

This document provides a detailed explanation of how we approached the implementation of our OS CPU Scheduler project, focusing on the challenges and solutions for each scheduling algorithm.

===== 1. DATA STRUCTURE DESIGN AND IMPLEMENTATION =====

1.1 Process Structure
--------------------
Our foundational data structure was the Process structure:

struct Process {
    int id;                  // Unique process identifier
    int arrival_time;        // When process enters system
    int run_time;            // Total CPU time needed
    int priority;            // Priority value (lower = higher)
    int remaining_time;      // Time left until completion
    int waiting_time;        // Time spent in ready queue
    int start_time;          // First CPU allocation time
    int finish_time;         // Completion time
    int last_stop_time;      // Last preemption time
    int preemption_count;    // Count of preemptions
    char state[20];          // Current state (running, ready, etc.)
};

We designed this structure to track all critical metrics needed for scheduling decisions and performance analysis. Each field serves a specific purpose:
- id/arrival_time/run_time/priority: Base information from process creation
- remaining_time: Dynamically updated during execution to track progress
- waiting_time: Accumulates time spent in ready queue
- start_time/finish_time: Used for turnaround time calculations
- last_stop_time: Critical for handling preemption correctly
- preemption_count: Tracks scheduling overhead
- state: String representation for logging

1.2 Queue Implementations
------------------------
Each scheduling algorithm required a specialized queue:

a) Priority Queue (HPF) - PriQueue.h
   We implemented a priority-based linked list that:
   - Maintains processes sorted by priority value
   - Uses arrival time as secondary sorting criteria
   - Provides O(1) access to highest priority process
   - Has O(n) insertion complexity
   
   Key design decisions:
   - Single "front" pointer (no rear pointer needed)
   - Manual priority maintenance during insertion
   - Tie-breaking by arrival time to ensure fairness

b) Standard Queue (SRTN) - Queue.h
   We implemented a basic FIFO queue but added:
   - Search functionality to find processes with specific attributes
   - Support for traversal to identify shortest remaining time
   - Ability to remove processes from arbitrary positions

c) Circular Queue (RR) - CircularQ.h
   We implemented an enhanced queue that:
   - Maintains both front and rear pointers for O(1) operations
   - Preserves strict FIFO ordering critical for RR fairness
   - Includes detailed debugging to track queue state
   - Has special handling for empty/full states

   The circular queue was particularly challenging and required special attention to ensure processes were always enqueued and dequeued in the correct order.

===== 2. SCHEDULING ALGORITHM IMPLEMENTATIONS =====

2.1 Highest Priority First (HPF)
-------------------------------
HPF is non-preemptive, so our implementation followed these steps:

a) Process Arrival Handling:
   - New processes are inserted into priority queue based on priority
   - Lower priority number = higher priority
   - For equal priorities, earlier arrival time takes precedence

b) Process Execution:
   - When CPU is free, select highest priority process that has arrived
   - Once started, process runs until completion (no preemption)
   - Update remaining_time until process finishes

c) Performance Tracking:
   - Waiting time = start_time - arrival_time
   - Turnaround time = finish_time - arrival_time
   - Weighted turnaround = turnaround_time / run_time

d) Implementation Challenges:
   - Ensuring proper priority ordering with tie-breaking
   - Tracking CPU utilization accurately
   - Avoiding starvation of low-priority processes (acknowledged limitation)

2.2 Shortest Remaining Time Next (SRTN)
--------------------------------------
SRTN is preemptive and required more complex logic:

a) Process Arrival:
   - New processes are added to regular queue
   - Immediately check if new process has shorter remaining time than running process

b) Scheduling Decisions:
   - At each clock tick, scan entire queue to find process with shortest remaining time
   - If no process is running, start process with shortest remaining time
   - If running process no longer has shortest remaining time, preempt it

c) Preemption Handling:
   - Save state of preempted process
   - Return process to queue
   - Start process with shorter remaining time
   - Increment preemption counter for statistics

d) Performance Calculations:
   - Waiting time = (finish_time - arrival_time) - run_time
   - Critical bug fix: Update para->total_waiting when process finishes
   - Without this update, average waiting time was incorrectly shown as 0.00

e) Implementation Challenges:
   - Efficient identification of shortest remaining time process
   - Ensuring preemption occurs immediately when shorter process arrives
   - Correctly calculating waiting time considering multiple preemptions
   - Fixing the average waiting time calculation bug

2.3 Round Robin (RR)
------------------
RR was the most complex to implement correctly:

a) Time Quantum Management:
   - Track quantum_start_time when process begins execution
   - At each clock tick, check if (current_time - quantum_start_time) >= quantum
   - If quantum expired, preempt process and add to back of queue

b) FIFO Queue Maintenance:
   - Strict ordering is critical for RR fairness
   - Processes must rejoin queue in exact order they were preempted
   - CircularQ implementation ensures O(1) operations for both ends

c) Process State Transitions:
   - started: First time process gets CPU
   - resumed: Process gets CPU after preemption
   - stopped: Process is preempted (quantum expired)
   - finished: Process completes execution

d) Edge Case Handling:
   - Empty queue: Nothing to schedule
   - Single process: Resume in same clock tick
   - Process arrival time verification: Only schedule if arrived
   - Quantum expiration exactly when process finishes

e) Critical Bug Fixes:
   - Process ordering in circular queue: Ensured strict FIFO
   - Timing of process resumption: Implemented same-clock-tick resumption
   - Verification of arrival times: Added explicit checks
   - Process state transitions: Ensured consistent handling

   The key insight was ensuring processes would consistently stop and resume in the same clock tick when they're the only eligible process.

===== 3. INTER-PROCESS COMMUNICATION =====

3.1 Shared Memory Implementation
------------------------------
We used two shared memory segments:

a) Process State Sharing:
   - Scheduler creates shared memory for current process
   - Process updates its remaining_time in shared memory
   - Scheduler reads updated state at each clock tick
   - Implementation used shmget/shmat/shmdt syscalls

b) Performance Metrics:
   - Shared Parameters structure tracks:
     * completed_processes
     * cpu_busy_time
     * total_wta (weighted turnaround)
     * total_waiting
     * total_wta_squared (for standard deviation)

3.2 Process Control Mechanisms
----------------------------
We implemented process control using:

a) Signal-based communication:
   - SIGUSR1: Process completion notification
   - SIGUSR2: Quantum expiration notification
   - SIGTSTP: Stop process (for preemption)
   - SIGCONT: Resume process execution

b) Process Creation:
   - fork() to create child process
   - execl() to run process executable
   - Passing scheduler PID and quantum value as arguments

c) Process Monitoring:
   - waitpid() with WNOHANG to check for completion
   - Signal handlers to detect status changes

===== 4. PERFORMANCE MONITORING AND LOGGING =====

4.1 Detailed Logging System
-------------------------
Our scheduler maintains comprehensive logs:

a) Process State Transitions:
   - Each state change is logged with timestamp
   - Format: "At time X process Y state arr W total Z remain Y wait K"
   - For completed processes, add "TA T WTA W" statistics

b) Performance Metrics:
   - CPU utilization = (busy_time / total_time) * 100%
   - Average waiting time = total_waiting / total_processes
   - Average weighted turnaround = total_wta / total_processes
   - Standard deviation of WTA for consistency analysis

4.2 Debug Assistance
------------------
We added extensive debugging support:

a) Queue state visualization:
   - Regular printing of queue contents
   - Process ID and key metrics for each queued process
   - Special handling for empty queues

b) Timestamp-based debugging:
   - All debug messages include current clock tick
   - Process state changes are precisely timestamped
   - Critical events (quantum expiration, preemption) have detailed logs

===== 5. CRITICAL CHALLENGES AND SOLUTIONS =====

5.1 Round Robin Implementation Challenges
---------------------------------------
The RR algorithm presented several critical challenges:

a) Process Order Preservation:
   - Challenge: Maintaining strict FIFO ordering after preemptions
   - Solution: Enhanced circular queue with careful enqueueing that always adds to the rear

b) Quantum Expiration Handling:
   - Challenge: Correctly detecting and handling quantum expiration
   - Solution: Precise tracking of quantum_start_time and comparison at each tick

c) Same-Tick Resumption:
   - Challenge: Processes would sometimes resume in the next clock tick
   - Solution: Implemented logic to resume processes in the same tick when appropriate

d) Queue Integrity:
   - Challenge: Queue corruption during preemption/resumption
   - Solution: Added extensive validation and debugging output

5.2 SRTN Performance Calculation
------------------------------
The SRTN algorithm had a critical bug:

a) Average Waiting Time Bug:
   - Challenge: Average waiting time was always showing as 0.00
   - Solution: Added missing code to update para->total_waiting when processes finish
   - Fix: para->total_waiting += running_process->waiting_time;

b) Preemption Decision Timing:
   - Challenge: Ensuring preemption happens immediately when shorter process arrives
   - Solution: Check for shorter process both during arrival and at each clock tick

5.3 Edge Case Handling
--------------------
We identified and fixed several edge cases:

a) Process Completion Detection:
   - Ensuring process completion is detected immediately
   - Properly freeing resources when processes finish

b) Empty Queue Handling:
   - Special checks for empty queues to avoid NULL pointer issues
   - Graceful handling when no processes are available

c) Process Arrival Verification:
   - Explicit checks that processes have arrived before scheduling
   - Returning processes to queue if scheduled too early

===== 6. PERFORMANCE COMPARISON AND ANALYSIS =====

6.1 Algorithm Tradeoffs
---------------------
Our implementation revealed important tradeoffs:

a) HPF:
   - Best for: Systems with clear priority distinctions
   - Weakness: Potential starvation of low-priority processes
   - Performance: High CPU utilization, lowest priority jobs suffer

b) SRTN:
   - Best for: Minimizing average waiting time
   - Weakness: High context switching overhead, complex implementation
   - Performance: Optimal average waiting time, favors short processes

c) RR:
   - Best for: Fair CPU time distribution, interactive systems
   - Weakness: Higher average waiting time than SRTN
   - Performance: No starvation, response time depends on quantum

6.2 Quantum Size Effects
---------------------
For RR, we experimented with different quantum values:

a) Small quantum (1-2 units):
   - More responsive system
   - Higher context switching overhead
   - Better for interactive workloads

b) Medium quantum (3-5 units):
   - Balanced performance
   - Reasonable context switching
   - Good general-purpose setting

c) Large quantum (8+ units):
   - Lower context switching overhead
   - Higher average waiting time
   - Behavior approaches FCFS as quantum increases

===== 7. CONCLUSION =====

Our CPU scheduler implementation demonstrated the intricate challenges of building a robust operating system component. The key insights from this project include:

1. Data structure design is critical for algorithm efficiency
2. Edge case handling is essential for system reliability
3. Process state tracking requires careful synchronization
4. Performance metrics must be calculated consistently
5. Each scheduling algorithm presents unique implementation challenges

The experience of debugging the Round Robin implementation particularly highlighted the importance of queue integrity and proper timing in scheduling decisions. The SRTN bug fix demonstrated the need for careful performance metric tracking.

By addressing these challenges, we created a robust scheduler implementation that correctly implements all three scheduling algorithms with proper performance tracking and analysis capabilities. 